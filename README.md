# Сервис сбора метрик и алертинга

## Инкремент 1

Сервер для сбора runtime-метрик, который принимает отчёты от агентов по протоколу `HTTP`.

Сервер доступен по адресу: `http://localhost:8080` и предоставляет следующие возможности:

- Принимать и хранить произвольные метрики двух типов:
  - **`gauge`** (`float64`) — новое значение замещает предыдущее.
  - **`counter`** (`int64`) — новое значение добавляется к предыдущему (если метрика уже известна серверу).
- Получать метрики через HTTP методом `POST`.
- Формат передачи данных:  
  `http://<АДРЕС_СЕРВЕРА>/update/<ТИП_МЕТРИКИ>/<ИМЯ_МЕТРИКИ>/<ЗНАЧЕНИЕ_МЕТРИКИ>`.
- Указывать заголовок:  
  `Content-Type: text/plain`.

### Условия обработки запросов:
1. При успешном приёме метрики сервер возвращает:  
   **`http.StatusOK (200)`**.
2. Если не указано имя метрики или путь некорректен, возвращается:  
   **`http.StatusNotFound (404)`**.
3. Если передан некорректный тип или значение метрики, сервер отвечает:  
   **`http.StatusBadRequest (400)`**.
4. Редиректы сервер не поддерживает.

### Хранение метрик:
Для хранения метрик реализуется структура `MemStorage`. Она должна быть оформлена как `struct`, содержащая коллекцию (`slice` или `map`). Это решение позволяет в дальнейшем добавлять функциональность, такую как логирование или мьютексы. Также потребуется интерфейс для взаимодействия с `MemStorage`.

### Пример запроса:
```http
POST /update/counter/someMetric/527 HTTP/1.1
Host: localhost:8080
Content-Length: 0
Content-Type: text/plain
```

### Пример ответа:
```http
HTTP/1.1 200 OK
Date: Tue, 21 Feb 2023 02:51:35 GMT
Content-Length: 11
Content-Type: text/plain; charset=utf-8
```

### Примечания:
- Все пограничные случаи и негативные сценарии должны быть обработаны.
- В будущих инкрементах автотесты станут строже — убедитесь, что код можно легко адаптировать.

---

## Инкремент 2

### Требования

Разработать **агент (HTTP-клиент)** для:
1. Сбора runtime-метрик.
2. Отправки метрик на сервер через HTTP.

### Типы метрик:
- **`gauge`** (`float64`)
- **`counter`** (`int64`)

### Источник данных:
Для получения метрик используется пакет `runtime`.

#### Метрики типа `gauge` для сбора:
- `Alloc`
- `BuckHashSys`
- `Frees`
- `GCCPUFraction`
- `GCSys`
- `HeapAlloc`
- `HeapIdle`
- `HeapInuse`
- `HeapObjects`
- `HeapReleased`
- `HeapSys`
- `LastGC`
- `Lookups`
- `MCacheInuse`
- `MCacheSys`
- `MSpanInuse`
- `MSpanSys`
- `Mallocs`
- `NextGC`
- `NumForcedGC`
- `NumGC`
- `OtherSys`
- `PauseTotalNs`
- `StackInuse`
- `StackSys`
- `Sys`
- `TotalAlloc`

#### Дополнительные метрики:
1. **`PollCount` (тип `counter`)** — счётчик, увеличивающийся на 1 при каждом обновлении метрик из `runtime` (в каждый `pollInterval`).
2. **`RandomValue` (тип `gauge`)** — произвольное, регулярно обновляемое значение.

#### Основное поведение агента:
- Метрики из `runtime` должны обновляться каждые `2 секунды` (**`pollInterval`**).
- Отправка метрик на сервер осуществляется каждые `10 секунд` (**`reportInterval`**).
  
Для реализации задержки между обновлениями и отправкой данных используйте `t.Sleep(n * t.Second)`.

### Отправка метрик

Метрики отправляются через HTTP методом POST.  
**Формат данных:**

`http://<АДРЕС_СЕРВЕРА>/update/<ТИП_МЕТРИКИ>/<ИМЯ_МЕТРИКИ>/<ЗНАЧЕНИЕ_МЕТРИКИ>`

- **Адрес сервера:**  
  `http://localhost:8080`.
- **Заголовок:**  
  `Content-Type: text/plain`.

#### Пример запроса:
```http
POST /update/counter/someMetric/527 HTTP/1.1
Host: localhost:8080
Content-Length: 0
Content-Type: text/plain
```

#### Пример ответа:
```http
HTTP/1.1 200 OK
Date: Tue, 21 Feb 2023 02:51:35 GMT
Content-Length: 11
Content-Type: text/plain; charset=utf-8
```

### Тестирование

- Код агента и сервера необходимо покрыть соответствующими **юнит-тестами**.

### Важно

Перед реализацией этого инкремента:
1. Убедитесь, что проект имеет модульную архитектуру с разделением на пакеты и слои, например:
   - **`handlers`**: для обработки HTTP-запросов.
   - **`storage`**: для логики хранения данных.
   - **`server`**: для запуска сервера.
2. В слое `storage` имплементируйте интерфейс, например, **`repositories`**. Это позволит:
   - Подменять хранилище моком в тестах.
   - Использовать Dependency Injection (DI).
   
Названия слоёв, типов и структур могут быть выбраны в соответствии с вашими предпочтениями.